<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>宇宙クリッカーゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            color: #e0e7ff; /* Light text color */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Prevent scroll */
            user-select: none; /* Disable text selection */
            -webkit-user-select: none; /* For Safari */
            -moz-user-select: none; /* For Firefox */
            -ms-user-select: none; /* For IE/Edge */
            cursor: default; /* Change cursor to default pointer */

            /* Base gradient and some subtle nebula effects */
            background:
                radial-gradient(circle at 10% 20%, rgba(30, 30, 80, 0.5) 0%, transparent 60%),
                radial-gradient(circle at 90% 80%, rgba(50, 20, 70, 0.5) 0%, transparent 60%),
                linear-gradient(to bottom, #0a0a0f, #1a1a2e); /* Main dark background */
        }

        /* Pseudo-elements for star layers */
        body::before, body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Behind content */
            background-repeat: repeat;
        }

        /* Layer 1: Distant, small, dense stars */
        body::before {
            background-image: radial-gradient(1.5px 1.5px at 10% 20%, #fff, transparent),
                              radial-gradient(1.5px 1.5px at 30% 70%, #fff, transparent),
                              radial-gradient(1.5px 1.5px at 60% 10%, #fff, transparent),
                              radial-gradient(1.5px 1.5px at 80% 90%, #fff, transparent),
                              radial-gradient(1.5px 1.5px at 5% 50%, #fff, transparent),
                              radial-gradient(1.5px 1.5px at 40% 40%, #fff, transparent);
            background-size: 800px 800px;
            animation: star-move-1 120s linear infinite;
        }

        /* Layer 2: Medium-sized, less dense stars */
        body::after {
            background-image: radial-gradient(2.5px 2.5px at 15% 85%, #fff, transparent),
                              radial-gradient(2.5px 2.5px at 70% 30%, #fff, transparent),
                              radial-gradient(2.5px 2.5px at 25% 60%, #fff, transparent),
                              radial-gradient(2.5px 2.5px at 95% 5%, #fff, transparent);
            background-size: 1500px 1500px;
            animation: star-move-2 200s linear infinite; /* Slower */
        }

        @keyframes star-move-1 {
            from { background-position: 0 0; }
            to { background-position: 800px 800px; }
        }

        @keyframes star-move-2 {
            from { background-position: 0 0; }
            to { background-position: -1500px -1500px; } /* Different direction */
        }

        .container {
            max-width: 90%;
            width: 100%;
            background-color: rgba(26, 26, 46, 0.8); /* Slightly transparent dark background */
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            height: 90vh; /* Maximize vertical space */
            margin: 20px auto;
        }
        .menu-button {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
        }
        .sidebar {
            width: 250px;
            min-width: 250px;
            background-color: #2a2a4a; /* Darker sidebar */
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            z-index: 90;
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            padding-top: 80px; /* Space for menu button */
            border-top-right-radius: 20px;
            border-bottom-right-radius: 20px;
        }
        .sidebar.open {
            transform: translateX(0);
        }

        /* New Upgrade Sidebar */
        .upgrades-sidebar {
            width: 300px; /* Slightly wider for upgrades */
            min-width: 300px;
            background-color: #2a2a4a; /* Darker sidebar */
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 950; /* Higher than main sidebar, lower than modals */
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            padding: 20px;
            border-top-left-radius: 20px;
            border-bottom-left-radius: 20px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }
        .upgrades-sidebar.open {
            transform: translateX(0);
        }
        .upgrades-sidebar-content {
            flex-grow: 1;
            overflow-y: auto; /* Allow scrolling for upgrade list */
            padding-right: 10px; /* Space for scrollbar */
        }
        .upgrades-sidebar .modal-close-button {
            position: absolute;
            top: 10px;
            right: 10px;
        }


        .main-content {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto; /* Allow scrolling for content */
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .star-clicker {
            width: 200px;
            height: 200px;
            font-size: 150px; /* Star emoji size */
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s ease-out;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: pulse 2s infinite; /* Pulsing effect for the star */
        }
        .star-clicker:active {
            transform: scale(0.95);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .upgrade-item {
            background-color: #3b3b6b;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        .upgrade-item button {
            background-color: #6a6aff;
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            /* Added box-shadow transition for smoothness */
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .upgrade-item button:hover {
            background-color: #4a4acb;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); /* Slightly larger shadow on hover */
        }
        /* Explicitly for disabled state to override default hover/active */
        .upgrade-item button[disabled] {
            background-color: #6b7280 !important; /* Tailwind gray-500, use !important to ensure override */
            cursor: not-allowed !important;
            pointer-events: none; /* Disables all mouse events, including hover */
            box-shadow: none !important; /* Remove shadow when disabled */
            opacity: 0.7; /* Slightly dim it */
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal.open {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #2a2a4a;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
            position: relative; /* For close button positioning */
        }
        .modal.open .modal-content {
            transform: translateY(0);
        }
        .modal-close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 24px;
            color: #ccc;
            cursor: pointer;
            padding: 5px;
        }
        .modal-button {
            background-color: #ff6b6b;
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            margin: 10px;
            transition: background-color 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .modal-button.confirm {
            background-color: #6aff6a;
        }
        .modal-button:hover {
            background-color: #e04a4a;
        }
        .modal-button.confirm:hover {
            background-color: #4acb4a;
        }

        /* Release Notes specific styles */
        .release-notes-content {
            text-align: left;
            max-height: 400px; /* Limit height for scrolling */
            overflow-y: auto;
            padding: 10px;
            background-color: #1a1a2e;
            border-radius: 10px;
            margin-top: 20px;
        }
        .release-notes-item {
            background-color: #2a2a4a;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .release-notes-item:last-child {
            margin-bottom: 0;
        }
        .release-notes-item h4 {
            font-size: 1.1em;
            font-weight: bold;
            color: #93c5fd; /* blue-300 */
            margin-bottom: 5px;
        }
        .release-notes-item p {
            font-size: 0.9em;
            color: #cbd5e1; /* slate-300 */
        }

        /* Volume slider specific styles */
        .volume-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            margin-bottom: 20px;
            color: #e0e7ff;
        }
        .volume-control input[type="range"] {
            width: 70%;
            -webkit-appearance: none;
            height: 8px;
            background: #4a4a6b;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .volume-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6a6aff;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .volume-control input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6a6aff;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .volume-icon svg {
            width: 24px;
            height: 24px;
            transition: color 0.2s ease-in-out; /* Smooth color transition for icon */
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <!-- Hamburger Menu Button -->
    <button id="menu-button" class="menu-button p-3 rounded-full bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition duration-200">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
        </svg>
    </button>

    <!-- Sidebar Navigation (Left) -->
    <nav id="sidebar" class="sidebar fixed top-0 left-0 w-64 h-full bg-gray-900 shadow-lg text-white p-6 transform -translate-x-full transition-transform duration-300 ease-in-out z-50 rounded-r-lg">
        <ul class="space-y-4 pt-10">
            <li>
                <a href="#" class="block px-4 py-2 text-lg font-semibold rounded-md hover:bg-gray-700 transition duration-200" data-modal="upgrades-sidebar-modal" data-scroll-to="regular-upgrades-section">全アップグレード</a>
            </li>
            <li>
                <a href="#" class="block px-4 py-2 text-lg font-semibold rounded-md hover:bg-gray-700 transition duration-200" data-modal="upgrades-sidebar-modal" data-scroll-to="one-time-upgrades-section">特別アップグレード</a>
            </li>
            <li>
                <a href="#" class="block px-4 py-2 text-lg font-semibold rounded-md hover:bg-gray-700 transition duration-200" data-modal="settings-modal">設定</a>
            </li>
            <li>
                <a href="#" class="block px-4 py-2 text-lg font-semibold rounded-md hover:bg-gray-700 transition duration-200" data-action="rebig-bang">リビッグバン</a>
            </li>
        </ul>
    </nav>

    <div class="container relative flex flex-col md:flex-row items-stretch overflow-hidden">
        <!-- Main Content Area -->
        <main class="main-content flex-grow p-6">
            <!-- Game Section -->
            <section id="game" class="section active flex flex-col items-center justify-center h-full text-center relative">
                <h1 class="text-4xl md:text-5xl font-bold mb-6 text-blue-300">スタークリック！</h1>
                <p class="text-2xl mb-4">
                    星からのエネルギー: <br> <span id="energy-display" class="font-bold text-yellow-300">0</span>
                </p>

                <div id="star-clicker" class="star-clicker flex justify-center items-center rounded-full bg-gradient-to-br from-yellow-400 to-orange-500 shadow-xl border-4 border-yellow-200 cursor-pointer select-none mx-auto relative z-20">
                    ⭐
                </div>
                <div class="flex flex-wrap justify-center gap-4 mt-8">
                    <p class="text-lg font-medium bg-gray-700 rounded-lg p-2 px-4 shadow-md">クリックパワー: <span id="click-power-display">1</span></p>
                    <p class="text-lg font-medium bg-gray-700 rounded-lg p-2 px-4 shadow-md">自動クリック: <span id="auto-click-display">0</span>/秒</p>
                    <!-- Heat Clicker Multiplier Display -->
                    <p id="heat-clicker-display-wrapper" class="text-lg font-medium bg-gray-700 rounded-lg p-2 px-4 shadow-md" style="display: none;">ヒートクリック: <span id="heat-multiplier-display" class="font-bold" style="color: hsl(0, 0%, 100%);">1.0x</span></p>
                </div>
            </section>
        </main>
    </div>

    <!-- Upgrades Sidebar Modal (Right) -->
    <div id="upgrades-sidebar-modal" class="upgrades-sidebar">
        <button class="modal-close-button" data-action="close-modal">&times;</button>
        <h2 class="text-3xl md:text-4xl font-bold mb-8 text-purple-300 text-center">アップグレード</h2>
        <div class="upgrades-sidebar-content">
            <h3 id="regular-upgrades-section" class="text-xl font-bold mb-4 mt-6 text-gray-300">惑星アップグレード</h3>
            <div id="regular-upgrade-list" class="grid grid-cols-1 gap-6">
                <!-- Regular Upgrade items will be dynamically inserted here -->
            </div>
            <h3 id="one-time-upgrades-section" class="text-xl font-bold mb-4 mt-6 text-gray-300">特別アップグレード</h3>
            <div id="one-time-upgrade-list" class="grid grid-cols-1 gap-6">
                <!-- One-Time Upgrade items will be dynamically inserted here -->
            </div>
        </div>
        <button id="close-upgrades-sidebar" class="mt-8 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-200 text-xl">
            閉じる
        </button>
    </div>

    <!-- Generic Confirmation Modal -->
    <div id="confirmation-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close-button" data-action="close-modal">&times;</button>
            <p id="modal-message" class="text-xl mb-6 text-gray-200">メッセージ</p>
            <div class="flex justify-center gap-4">
                <button id="modal-cancel" class="modal-button bg-gray-500 hover:bg-gray-600">キャンセル</button>
                <button id="modal-confirm" class="modal-button confirm bg-red-600 hover:bg-red-700">はい、削除します</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close-button" data-action="close-modal">&times;</button>
            <h2 class="text-3xl md:text-4xl font-bold mb-8 text-red-300 text-center">設定</h2>

            <!-- Volume Control -->
            <div class="volume-control">
                <span id="speaker-icon" class="volume-icon cursor-pointer">
                    <!-- SVG for volume icon, dynamically updated -->
                    <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor">
                        <path d="M14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77zM3 9v6h4l5 5V4L7 9H3z"/>
                    </svg>
                </span>
                <input type="range" id="volume-slider" min="0" max="100" value="50">
            </div>

            <button id="release-notes-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-200 text-xl mb-4">
                リリースノート
            </button>
            <button id="delete-data-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-200 text-xl mb-4">
                データを削除
            </button>
            <button id="close-settings-modal" class="mt-4 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-xl shadow-lg transition duration-200">
                閉じる
            </button>
        </div>
    </div>

    <!-- Release Notes Modal -->
    <div id="release-notes-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close-button" data-action="close-modal">&times;</button>
            <h2 class="text-3xl md:text-4xl font-bold mb-8 text-blue-300 text-center">リリースノート</h2>
            <div id="release-notes-content" class="release-notes-content">
                <!-- Release notes will be dynamically inserted here -->
            </div>
            <button id="close-release-notes-modal" class="mt-8 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-xl shadow-lg transition duration-200">
                閉じる
            </button>
        </div>
    </div>

    <!-- Audio Element -->
    <audio id="background-music" loop src="https://minntogames.github.io/minnntogames.github.io2/edge.wav"></audio>

    <script>
        // IndexedDB configuration
        const DB_NAME = 'SpaceClickerDB';
        const STORE_NAME = 'gameState';
        const DB_VERSION = 1;
        const BASE_STRONG_START_ENERGY_REQUIREMENT = 1000000; // 1 million energy base cost
        const MAX_INACTIVITY_MS = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
        const HEAT_CLICKER_RESET_TIME_MS = 2000; // 2 seconds of inactivity to reset heat clicker multiplier
        const HEAT_CLICKER_INCREMENT = 0.1; // Multiplier increases by this much per click
        const MAX_HEAT_CLICK_MULTIPLIER = 2.0; // Maximum limit for heat clicker multiplier

        let db; // IndexedDB database instance
        let gameState = {
            energy: 0,
            clickPower: 1,
            autoClickPower: 0,
            strongStartLevel: 0, // Tracks how many strong starts have been initiated
            lastPlayedTime: Date.now(), // Store last active time
            heatClickMultiplier: 1.0, // Multiplier for heat clicker
            lastClickTime: Date.now(), // Last time the star was clicked
            upgrades: {
                mercury: { level: 0, cost: 10, clickBonus: 1, autoBonus: 0, icon: '☿' },
                venus: { level: 0, cost: 50, clickBonus: 3, autoBonus: 0, icon: '♀' },
                earth: { level: 0, cost: 200, clickBonus: 0, autoBonus: 5, icon: '🌎' },
                mars: { level: 0, cost: 1000, clickBonus: 10, autoBonus: 0, icon: '♂' },
                jupiter: { level: 0, cost: 5000, clickBonus: 0, autoBonus: 50, icon: '♃' },
                saturn: { level: 0, cost: 25000, clickBonus: 0, autoBonus: 200, icon: '♄' },
                uranus: { level: 0, cost: 100000, clickBonus: 50, autoBonus: 0, icon: '⛢' },
                neptune: { level: 0, cost: 500000, clickBonus: 0, autoBonus: 1000, icon: '♆' },
                originalPlanetX: { level: 0, cost: 2000000, clickBonus: 500, autoBonus: 5000, icon: '🪐' }, // Original Planet
                // New one-time upgrades
                cosmicDrill: { level: 0, initialCost: 1e7, cost: 1e7, clickBonus: 10000, autoBonus: 0, icon: '⛏️', maxLevel: 1 },
                galacticReactor: { level: 0, initialCost: 5e7, cost: 5e7, clickBonus: 0, autoBonus: 10000, icon: '⚛️', maxLevel: 1 },
                heatClicker: { level: 0, initialCost: 1e6, cost: 1e6, clickBonus: 0, autoBonus: 0, icon: '🔥', maxLevel: 1 } // Heat Clicker
            },
            volume: 0.5 // Default volume (0.0 to 1.0)
        };

        // Release Notes Data
        const releaseNotesData = [
            { version: "v1.2", date: "2024-06-20", notes: "ゲームにBGMを追加し、設定に音量スライダーとミュート機能を追加しました。" },
            { version: "v1.1", date: "2024-06-19", notes: "新しいアップグレードと細かい調整" },
            { version: "v1.0", date: "2024-06-18", notes: "ゲームがリリースされました" }
        ];

        // DOM Elements
        const energyDisplay = document.getElementById('energy-display');
        const clickPowerDisplay = document.getElementById('click-power-display');
        const autoClickDisplay = document.getElementById('auto-click-display');
        const starClicker = document.getElementById('star-clicker');
        // Separated upgrade lists
        const regularUpgradeList = document.getElementById('regular-upgrade-list');
        const oneTimeUpgradeList = document.getElementById('one-time-upgrade-list');
        const heatClickerDisplayWrapper = document.getElementById('heat-clicker-display-wrapper'); // Wrapper for heat clicker display
        const heatMultiplierDisplay = document.getElementById('heat-multiplier-display');

        const menuButton = document.getElementById('menu-button');
        const sidebar = document.getElementById('sidebar');
        const navLinks = document.querySelectorAll('#sidebar a');
        const sections = document.querySelectorAll('.section');

        // Modals / Sidebars
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalCancelButton = document.getElementById('modal-cancel');
        const modalConfirmButton = document.getElementById('modal-confirm');
        const settingsModal = document.getElementById('settings-modal');
        const deleteDataButton = document.getElementById('delete-data-button');
        const closeSettingsModalButton = document.getElementById('close-settings-modal');
        const modalCloseButtons = document.querySelectorAll('.modal-close-button'); // Includes new buttons on sidebar modals

        // Upgrades Sidebar Modal elements
        const upgradesSidebarModal = document.getElementById('upgrades-sidebar-modal');
        const closeUpgradesSidebarButton = document.getElementById('close-upgrades-sidebar');

        // Release Notes Modal elements
        const releaseNotesButton = document.getElementById('release-notes-button');
        const releaseNotesModal = document.getElementById('release-notes-modal');
        const releaseNotesContent = document.getElementById('release-notes-content');
        const closeReleaseNotesModalButton = document.getElementById('close-release-notes-modal');

        // Audio Elements
        const audioElement = document.getElementById('background-music');
        const volumeSlider = document.getElementById('volume-slider');
        const speakerIcon = document.getElementById('speaker-icon');

        let currentConfirmCallback = null;
        let currentCancelCallback = null;
        let confirmationStep = 0; // For multi-step deletion confirmation
        let lastVolumeBeforeMute = gameState.volume; // Store volume before muting

        // --- Helper Functions ---

        /**
         * Formats a large number with units (K, M, B, T).
         * @param {number} num - The number to format.
         * @returns {string} The formatted number string.
         */
        function formatNumber(num) {
            if (num >= 1000000000000) {
                return (num / 1000000000000).toFixed(2) + 'T';
            }
            if (num >= 1000000000) {
                return (num / 1000000000).toFixed(2) + 'B';
            }
            if (num >= 1000000) {
                return (num / 1000000).toFixed(2) + 'M';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(2) + 'K';
            }
            return Math.floor(num).toLocaleString();
        }

        /**
         * Calculates the current energy cost for a "Strong New Game".
         * Cost increases exponentially with each strong start level.
         * @returns {number} The required energy for the next strong start.
         */
        function getStrongStartCurrentCost() {
            // Using Math.pow(2, ...) for a more noticeable exponential increase
            return BASE_STRONG_START_ENERGY_REQUIREMENT * Math.pow(2, gameState.strongStartLevel);
        }

        /**
         * Calculates HSL color for the heat multiplier display, from white to red.
         * @param {number} multiplier - The current heat click multiplier.
         * @returns {string} HSL color string.
         */
        function getHeatColor(multiplier) {
            const minMultiplier = 1.0;
            const maxMultiplier = MAX_HEAT_CLICK_MULTIPLIER;
            // Normalize the multiplier to a 0-1 range based on its min/max
            const normalized = Math.max(0, Math.min(1, (multiplier - minMultiplier) / (maxMultiplier - minMultiplier)));

            // Interpolate HSL values.
            // Hue (H) remains 0 for red/white/gray.
            // Saturation (S) goes from 0% (white) to 100% (red).
            // Lightness (L) goes from 100% (white) down to 50% (pure red).
            const h = 0;
            const s = normalized * 100; // Saturation increases from 0 to 100
            const l = 100 - (normalized * 50); // Lightness decreases from 100 to 50

            return `hsl(${h}, ${s}%, ${l}%)`;
        }

        /**
         * Updates the speaker icon based on volume level.
         * @param {number} volume - The current volume (0-1).
         * @param {boolean} isMuted - Whether the audio is currently muted.
         */
        function updateSpeakerIcon(volume, isMuted) {
            let pathD;
            if (isMuted || volume === 0) {
                // Volume Off icon
                pathD = "M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C19.56 15.34 20 13.73 20 12c0-3.28-2.11-6.04-5-6.81v2.06c2.22.82 3.79 3.02 3.79 5.09zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.27 4.27L16 21.73l1.73-1.73L21.73 21 23 19.73 4.27 3zM12 4L9.17 7H5v4h3.17l3.83 3.83V4z";
            } else if (volume > 0 && volume <= 0.5) {
                // Volume Down icon (low volume)
                pathD = "M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z";
            } else {
                // Volume Up icon (medium/high volume)
                pathD = "M14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77zM3 9v6h4l5 5V4L7 9H3z";
            }
            speakerIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="${pathD}"/></svg>`;
        }

        // --- IndexedDB Functions ---

        /**
         * Initializes the IndexedDB database.
         * Creates the object store if it doesn't exist.
         */
        function initDb() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('IndexedDB initialized successfully.');
                    resolve();
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        /**
         * Saves the current game state to IndexedDB.
         */
        async function saveGame() {
            if (!db) {
                console.error("IndexedDB not initialized, cannot save.");
                return;
            }
            // Update lastPlayedTime before saving
            gameState.lastPlayedTime = Date.now();
            // Save current volume
            gameState.volume = audioElement.volume;
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.put(gameState, 'gameData'); // Use a fixed key 'gameData'

            request.onsuccess = () => {
                // console.log('Game saved.');
            };

            request.onerror = (event) => {
                console.error('Error saving game:', event.target.errorCode);
            };
        }

        /**
         * Loads the game state from IndexedDB.
         * If no data is found, returns the initial game state.
         */
        async function loadGame() {
            if (!db) {
                console.error("IndexedDB not initialized, cannot load.");
                return;
            }
            return new Promise((resolve) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('gameData');

                request.onsuccess = (event) => {
                    let loadedState = event.target.result;
                    if (loadedState) {
                        // Merge loaded state with default to ensure new properties exist
                        // This handles cases where new upgrades or properties are added to gameState
                        // but not present in older saved data.
                        gameState.energy = loadedState.energy || 0;
                        gameState.clickPower = loadedState.clickPower || 1;
                        gameState.autoClickPower = loadedState.autoClickPower || 0;
                        gameState.strongStartLevel = loadedState.strongStartLevel || 0;
                        gameState.lastPlayedTime = loadedState.lastPlayedTime || Date.now();
                        gameState.heatClickMultiplier = loadedState.heatClickMultiplier || 1.0;
                        gameState.lastClickTime = loadedState.lastClickTime || Date.now();
                        // Load volume, default to 0.5 if not present
                        gameState.volume = loadedState.volume !== undefined ? loadedState.volume : 0.5;


                        for (const key in gameState.upgrades) {
                            if (loadedState.upgrades && loadedState.upgrades[key]) {
                                // For existing upgrades, load saved level and cost
                                gameState.upgrades[key].level = loadedState.upgrades[key].level;
                                gameState.upgrades[key].cost = loadedState.upgrades[key].cost;
                            } else {
                                // If a new upgrade was added, initialize it to its default
                                // initialCost property is used for one-time upgrades to reset
                                if (gameState.upgrades[key].initialCost) {
                                    gameState.upgrades[key].cost = gameState.upgrades[key].initialCost;
                                }
                                gameState.upgrades[key].level = 0;
                            }
                        }

                        // Handle offline earnings
                        if (gameState.lastPlayedTime) {
                            const currentTime = Date.now();
                            let timeAway = currentTime - gameState.lastPlayedTime;
                            timeAway = Math.min(timeAway, MAX_INACTIVITY_MS); // Cap at 24 hours

                            const offlineEnergy = (gameState.autoClickPower / 1000) * timeAway; // autoClickPower is per second
                            if (offlineEnergy > 0) {
                                gameState.energy += offlineEnergy;
                                showGenericModal(confirmationModal, `オフライン中に ${formatNumber(offlineEnergy)} エネルギーを獲得しました！`, null, () => hideModal(confirmationModal), 'OK', 'bg-green-600 hover:bg-green-700', '閉じる');
                                modalConfirmButton.style.display = 'none'; // Hide OK button, only '閉じる'
                            }
                        }
                        console.log('Game loaded.');
                    } else {
                        console.log('No saved game found, starting new game.');
                        // gameState already defaults to initial state
                    }
                    updateDisplay();
                    resolve();
                };

                request.onerror = (event) => {
                    console.error('Error loading game:', event.target.errorCode);
                    updateDisplay(); // Ensure display is updated even on error
                    resolve(); // Resolve to proceed even if loading fails
                };
            });
        }

        /**
         * Clears all game data from IndexedDB.
         */
        async function clearGameData() {
            if (!db) {
                console.error("IndexedDB not initialized, cannot clear data.");
                return;
            }
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.clear();

                request.onsuccess = () => {
                    console.log('Game data cleared from IndexedDB.');
                    resolve();
                };

                request.onerror = (event) => {
                    console.error('Error clearing game data:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        // --- Game Logic ---

        /**
         * Auto-clicks based on auto-click power.
         */
        function autoClickLoop() {
            gameState.energy += gameState.autoClickPower / 10; // Divide by 10 for 100ms interval
            updateDisplay();
        }

        /**
         * Checks if heat clicker multiplier should be reset due to inactivity.
         */
        function checkHeatClickerReset() {
            if (gameState.upgrades.heatClicker && gameState.upgrades.heatClicker.level > 0 &&
                gameState.heatClickMultiplier > 1.0 && // Only reset if already boosted
                Date.now() - gameState.lastClickTime >= HEAT_CLICKER_RESET_TIME_MS) {
                gameState.heatClickMultiplier = 1.0; // Reset to base multiplier
                updateDisplay(); // Update display to reflect reset
            }
        }

        /**
         * Updates the display elements with current game state.
         */
        function updateDisplay() {
            energyDisplay.textContent = formatNumber(gameState.energy);
            clickPowerDisplay.textContent = formatNumber(gameState.clickPower);
            autoClickDisplay.textContent = formatNumber(gameState.autoClickPower);
            // renderUpgrades() is now called only on upgrade purchase or initial load
            // to prevent scroll issues.

            // Update heat clicker display visibility and value
            if (gameState.upgrades.heatClicker && gameState.upgrades.heatClicker.level > 0) {
                heatClickerDisplayWrapper.style.display = 'block';
                heatMultiplierDisplay.textContent = `${gameState.heatClickMultiplier.toFixed(1)}x`;
                heatMultiplierDisplay.style.color = getHeatColor(gameState.heatClickMultiplier);
            } else {
                heatClickerDisplayWrapper.style.display = 'none';
            }

            saveGame(); // Save game state whenever display is updated (implies state change)
        }

        /**
         * Handles the star click event.
         */
        function clickStar() {
            // Ensure music starts playing on first interaction if not already playing
            if (audioElement.paused) {
                audioElement.play().catch(e => console.error("Autoplay failed:", e));
            }

            // Apply heat clicker bonus first if active
            if (gameState.upgrades.heatClicker && gameState.upgrades.heatClicker.level > 0) {
                const currentTime = Date.now();
                if (currentTime - gameState.lastClickTime < HEAT_CLICKER_RESET_TIME_MS) {
                    gameState.heatClickMultiplier = Math.min(MAX_HEAT_CLICK_MULTIPLIER, gameState.heatClickMultiplier + HEAT_CLICKER_INCREMENT);
                } else {
                    // Reset and start with first increment
                    gameState.heatClickMultiplier = Math.min(MAX_HEAT_CLICK_MULTIPLIER, 1.0 + HEAT_CLICKER_INCREMENT);
                }
                gameState.lastClickTime = currentTime;
                // Add base click power, then the bonus from multiplier
                gameState.energy += gameState.clickPower * gameState.heatClickMultiplier;
            } else {
                gameState.energy += gameState.clickPower; // Normal click power
                gameState.heatClickMultiplier = 1.0; // Ensure reset if not active
            }
            updateDisplay();
        }

        /**
         * Renders the upgrade items in the upgrades section.
         */
        function renderUpgrades() {
            // Store current scroll position before clearing
            const upgradesSidebarContent = upgradesSidebarModal.querySelector('.upgrades-sidebar-content');
            const upgradesScrollTop = upgradesSidebarContent ? upgradesSidebarContent.scrollTop : 0; // Check if element exists

            regularUpgradeList.innerHTML = ''; // Clear previous regular upgrades
            oneTimeUpgradeList.innerHTML = ''; // Clear previous one-time upgrades

            const upgradeKeys = Object.keys(gameState.upgrades);

            // Preserve the default order of the upgrade list
            // No sorting applied.

            upgradeKeys.forEach(key => {
                const upgrade = gameState.upgrades[key];
                // Heat Clicker is now a separate display, so don't render it in the upgrades list if purchased.
                if (key === 'heatClicker' && upgrade.level > 0) {
                    return; // Skip rendering heat clicker in the list if it's already purchased
                }

                const upgradeElement = createUpgradeElement(key, upgrade);

                if (upgrade.maxLevel === 1) {
                    oneTimeUpgradeList.appendChild(upgradeElement);
                } else {
                    regularUpgradeList.appendChild(upgradeElement);
                }
            });

            // Restore scroll position after rendering
            // Added a small delay to ensure DOM is rendered before attempting to scroll
            if (upgradesSidebarContent) {
                setTimeout(() => {
                    upgradesSidebarContent.scrollTop = upgradesScrollTop;
                }, 50); // Small delay
            }
        }

        // Helper function to create an individual upgrade element
        function createUpgradeElement(key, upgrade) {
            const upgradeElement = document.createElement('div');
            upgradeElement.className = 'upgrade-item';

            let upgradeStatusText = '';
            let isPurchasedOneTime = (upgrade.maxLevel === 1 && upgrade.level >= 1);

            if (isPurchasedOneTime) {
                upgradeStatusText = `<p class="text-sm text-green-400 font-bold">購入済み</p>`;
            } else {
                upgradeStatusText = `<p class="text-lg font-bold mb-2">コスト: ${formatNumber(upgrade.cost)}</p>`;
            }

            upgradeElement.innerHTML = `
                <div class="flex items-center">
                    <span class="upgrade-icon">${upgrade.icon}</span>
                    <div>
                        <h3 class="text-xl font-semibold">${key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1').trim()}</h3>
                        <p class="text-sm text-gray-400">レベル: ${upgrade.level}</p>
                        ${upgrade.clickBonus > 0 ? `<p class="text-sm text-gray-400">クリックパワー +${formatNumber(upgrade.clickBonus)}</p>` : ''}
                        ${upgrade.autoBonus > 0 ? `<p class="text-sm text-gray-400">自動クリック +${formatNumber(upgrade.autoBonus)}/秒</p>` : ''}
                    </div>
                </div>
                <div>
                    ${upgradeStatusText}
                    <button data-upgrade="${key}" class="buy-upgrade px-5 py-2 rounded-lg font-semibold transition duration-200">
                        購入
                    </button>
                </div>
            `;
            const buyButton = upgradeElement.querySelector('.buy-upgrade');

            // Bug fix: Ensure button is correctly enabled/disabled based on current energy and purchase status
            if (isPurchasedOneTime || gameState.energy < upgrade.cost) {
                buyButton.disabled = true;
                buyButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                buyButton.classList.add('bg-gray-500'); // Apply disabled style
                if (isPurchasedOneTime) {
                    buyButton.textContent = '完了';
                } else {
                    buyButton.textContent = '購入'; // Set text to '購入' if disabled due to cost
                }
            } else {
                buyButton.disabled = false;
                buyButton.classList.remove('bg-gray-500'); // Ensure disabled style is removed
                buyButton.classList.add('bg-blue-600', 'hover:bg-blue-700'); // Apply active styles
                buyButton.textContent = '購入';
            }
            buyButton.addEventListener('click', buyUpgrade);
            return upgradeElement;
        }

        /**
         * Handles the purchase of an upgrade.
         * @param {Event} event - The click event.
         */
        function buyUpgrade(event) {
            const upgradeKey = event.target.dataset.upgrade;
            const upgrade = gameState.upgrades[upgradeKey];

            // Check if it's a one-time upgrade and already purchased
            if (upgrade.maxLevel === 1 && upgrade.level >= 1) {
                console.log("This upgrade can only be purchased once.");
                return;
            }

            if (gameState.energy >= upgrade.cost) {
                gameState.energy -= upgrade.cost;
                gameState.clickPower += upgrade.clickBonus;
                gameState.autoClickPower += upgrade.autoBonus;
                upgrade.level++;
                if (upgrade.maxLevel !== 1) { // Only increase cost if not a one-time upgrade
                    upgrade.cost = Math.floor(upgrade.cost * 1.5); // Increase cost for next level
                }
                updateDisplay();
                renderUpgrades(); // Re-render upgrades after purchase to update button states
            } else {
                console.log("Not enough energy to buy " + upgradeKey);
            }
        }

        /**
         * Resets the game to its initial state.
         * @param {boolean} strongStart - If true, apply strong start bonuses.
         */
        async function resetGame(strongStart = false) {
            // Save current strongStartLevel before clearing if strongStart is true
            const prevStrongStartLevel = gameState.strongStartLevel;

            await clearGameData(); // Clear IndexedDB first

            // Reset game state, increment strongStartLevel if it's a strong start
            let newStrongStartLevel = strongStart ? prevStrongStartLevel + 1 : 0;

            // Deep copy of initial upgrades to ensure a clean reset, especially for costs
            let initialUpgrades = JSON.parse(JSON.stringify({
                mercury: { level: 0, cost: 10, clickBonus: 1, autoBonus: 0, icon: '☿' },
                venus: { level: 0, cost: 50, clickBonus: 3, autoBonus: 0, icon: '♀' },
                earth: { level: 0, cost: 200, clickBonus: 0, autoBonus: 5, icon: '🌎' },
                mars: { level: 0, cost: 1000, clickBonus: 10, autoBonus: 0, icon: '♂' },
                jupiter: { level: 0, cost: 5000, clickBonus: 0, autoBonus: 50, icon: '♃' },
                saturn: { level: 0, cost: 25000, clickBonus: 0, autoBonus: 200, icon: '♄' },
                uranus: { level: 0, cost: 100000, clickBonus: 50, autoBonus: 0, icon: '⛢' },
                neptune: { level: 0, cost: 500000, clickBonus: 0, autoBonus: 1000, icon: '♆' },
                originalPlanetX: { level: 0, cost: 2000000, clickBonus: 500, autoBonus: 5000, icon: '🪐' },
                cosmicDrill: { level: 0, initialCost: 1e7, cost: 1e7, clickBonus: 10000, autoBonus: 0, icon: '⛏️', maxLevel: 1 },
                galacticReactor: { level: 0, initialCost: 5e7, cost: 5e7, clickBonus: 0, autoBonus: 10000, icon: '⚛️', maxLevel: 1 },
                heatClicker: { level: 0, initialCost: 1e6, cost: 1e6, clickBonus: 0, autoBonus: 0, icon: '🔥', maxLevel: 1 }
            }));

            gameState = {
                energy: 0,
                clickPower: 1,
                autoClickPower: 0,
                strongStartLevel: newStrongStartLevel,
                lastPlayedTime: Date.now(), // Reset lastPlayedTime on new game
                heatClickMultiplier: 1.0, // Reset on new game
                lastClickTime: Date.now(), // Reset on new game
                upgrades: initialUpgrades,
                volume: 0.5 // Reset volume to default
            };

            if (strongStart) {
                // Bonuses scale with strongStartLevel
                // Level 0 (first strong start) means multiplier is 1.0
                // Level 1 means multiplier is 1.1, etc.
                const bonusMultiplier = 1 + (newStrongStartLevel * 0.1);

                gameState.energy = 1000 * bonusMultiplier;
                gameState.clickPower = 10 * bonusMultiplier;
                gameState.autoClickPower = 1 * bonusMultiplier;

                // Apply initial levels to regular upgrades, also scaled by strongStartLevel
                for (const key in gameState.upgrades) {
                    if (gameState.upgrades[key].maxLevel !== 1) { // Apply bonus only to non-one-time upgrades
                        const initialLevel = key === 'mercury' ? 5 : (key === 'venus' ? 2 : 0); // Base levels for certain upgrades
                        const calculatedLevel = Math.floor(initialLevel * bonusMultiplier);

                        if (calculatedLevel > 0) { // Only apply if level is positive
                            gameState.upgrades[key].level = calculatedLevel;
                            // Ensure the cost is recalculated based on the new level
                            // If initialCost exists, use it as a base for calculations, otherwise use current cost.
                            // This ensures upgrades correctly reset their cost for the *next* level if they were initially 0.
                            gameState.upgrades[key].cost = Math.floor((gameState.upgrades[key].initialCost || gameState.upgrades[key].cost) * Math.pow(1.5, calculatedLevel));
                            gameState.clickPower += gameState.upgrades[key].clickBonus * calculatedLevel;
                            gameState.autoClickPower += gameState.upgrades[key].autoBonus * calculatedLevel;
                        }
                    }
                }
            }
            // Update audio settings after reset
            audioElement.volume = gameState.volume;
            volumeSlider.value = gameState.volume * 100;
            updateSpeakerIcon(audioElement.volume, audioElement.muted);

            updateDisplay();
            renderUpgrades(); // Re-render upgrades after reset
            hideModal(confirmationModal);
            hideModal(settingsModal); // Ensure settings modal is also hidden
            hideModal(upgradesSidebarModal); // Ensure upgrades sidebar is also hidden
            hideModal(releaseNotesModal); // Ensure release notes modal is also hidden
            // Switch back to game section after reset
            showSection('game');
        }

        // --- UI Functions ---

        /**
         * Shows a specific section and hides others.
         * @param {string} sectionId - The ID of the section to show.
         */
        function showSection(sectionId) {
            sections.forEach(section => {
                if (section.id === sectionId) {
                    section.classList.add('active');
                } else {
                    section.classList.remove('active');
                }
            });
            sidebar.classList.remove('open'); // Close left sidebar after selection
            hideModal(upgradesSidebarModal); // Also hide upgrades sidebar if a main section is shown
            hideModal(settingsModal); // Ensure settings modal is also hidden
            hideModal(releaseNotesModal); // Ensure release notes modal is also hidden
        }

        /**
         * Shows a modal and sets its content and callbacks.
         * @param {HTMLElement} modalElement - The modal DOM element.
         * @param {string} message - The message for the confirmation modal.
         * @param {function} confirmCallback - Callback for the confirm button.
         * @param {function} cancelCallback - Callback for the cancel button.
         * @param {string} confirmButtonText - Text for the confirm button.
         * @param {string} confirmButtonClass - Tailwind class for the confirm button background.
         * @param {string} cancelButtonText - Text for the cancel button.
         */
        function showGenericModal(modalElement, message, confirmCallback, cancelCallback, confirmButtonText = 'はい', confirmButtonClass = 'bg-red-600 hover:bg-red-700', cancelButtonText = 'キャンセル') {
            if (modalElement === confirmationModal) {
                modalMessage.textContent = message;

                // Reset default states for buttons
                modalConfirmButton.style.display = 'inline-block';
                modalConfirmButton.disabled = false;
                modalConfirmButton.textContent = confirmButtonText;
                modalConfirmButton.className = 'modal-button confirm ' + confirmButtonClass;

                modalCancelButton.textContent = cancelButtonText;
                modalCancelButton.style.display = 'inline-block'; // Ensure cancel button is also visible by default
            }

            currentConfirmCallback = confirmCallback;
            currentCancelCallback = cancelCallback;

            modalElement.classList.add('open');
        }

        /**
         * Hides a modal.
         * @param {HTMLElement} modalElement - The modal DOM element to hide.
         */
        function hideModal(modalElement) {
            modalElement.classList.remove('open');
            currentConfirmCallback = null;
            currentCancelCallback = null;

            // Reset confirmation modal button styles to default when hidden
            if (modalElement === confirmationModal) {
                modalConfirmButton.style.display = 'inline-block';
                modalConfirmButton.disabled = false;
                modalCancelButton.textContent = 'キャンセル';
                // Reset button text and class to default for future uses (e.g., delete data)
                modalConfirmButton.textContent = 'はい、削除します'; // Default for delete
                modalConfirmButton.classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'bg-green-600', 'hover:bg-green-700', 'bg-blue-600', 'hover:bg-blue-700', 'bg-red-800', 'hover:bg-red-900');
                modalConfirmButton.classList.add('bg-red-600', 'hover:bg-red-700');
            }
        }

        /**
         * Renders the release notes into the release notes modal.
         */
        function renderReleaseNotes() {
            releaseNotesContent.innerHTML = ''; // Clear previous notes
            releaseNotesData.forEach(release => {
                const releaseItem = document.createElement('div');
                releaseItem.className = 'release-notes-item';
                releaseItem.innerHTML = `
                    <h4>${release.version} (${release.date})</h4>
                    <p>${release.notes}</p>
                `;
                releaseNotesContent.appendChild(releaseItem);
            });
        }

        /**
         * Handles multi-step deletion confirmation logic.
         */
        function confirmDeleteData() {
            // Hide settings modal before showing confirmation modal
            hideModal(settingsModal);

            if (confirmationStep === 0) {
                showGenericModal(confirmationModal, "本当にすべてのゲームデータを削除しますか？これは元に戻せません。", confirmDeleteData, () => { confirmationStep = 0; hideModal(confirmationModal); settingsModal.classList.add('open'); }, 'はい、削除します', 'bg-red-600 hover:bg-red-700');
                confirmationStep++;
            } else if (confirmationStep === 1) {
                showGenericModal(confirmationModal, "最終確認: 本当に本当にすべてのゲームデータを削除しますか？", confirmDeleteData, () => { confirmationStep = 0; hideModal(confirmationModal); settingsModal.classList.add('open'); }, '本当に削除します！', 'bg-yellow-600 hover:bg-yellow-700'); // Change color for extra warning
                confirmationStep++;
            } else if (confirmationStep === 2) {
                showGenericModal(confirmationModal, "最後の確認: ゲームデータはすべて失われます。よろしいですか？", confirmDeleteData, () => { confirmationStep = 0; hideModal(confirmationModal); settingsModal.classList.add('open'); }, '確認して削除！', 'bg-red-800 hover:bg-red-900'); // Even stronger warning color
                confirmationStep++;
            } else if (confirmationStep === 3) {
                resetGame(false); // Perform full reset (not strong start)
                confirmationStep = 0; // Reset for next time
                hideModal(confirmationModal);
                hideModal(settingsModal); // Ensure settings modal is also hidden after full reset
            }
        }

        /**
         * Handles Rebig Bang confirmation logic.
         */
        function confirmRebigBang() {
            const requiredEnergy = getStrongStartCurrentCost();
            if (gameState.energy < requiredEnergy) {
                showGenericModal(confirmationModal, `リビッグバンには ${formatNumber(requiredEnergy)} エネルギーが必要です。現在のエネルギーは ${formatNumber(gameState.energy)} です。`, null, () => hideModal(confirmationModal), 'OK', 'bg-blue-600 hover:bg-blue-700', '閉じる');
                modalConfirmButton.style.display = 'none'; // Hide the 'OK' button, user only clicks '閉じる'
                return;
            }

            showGenericModal(confirmationModal, `リビッグバンを開始します。現在のデータはすべて削除され、レベル ${gameState.strongStartLevel + 1} のボーナス付きで開始されます。よろしいですか？`,
                () => { // Confirm Callback
                    resetGame(true);
                    hideModal(confirmationModal);
                },
                () => { // Cancel Callback
                    hideModal(confirmationModal);
                },
                '開始！',
                'bg-green-600 hover:bg-green-700'
            );
        }

        // --- Event Listeners ---

        // Star clicker
        starClicker.addEventListener('click', clickStar);

        // Menu button toggle
        menuButton.addEventListener('click', () => {
            sidebar.classList.toggle('open');
        });

        // Navigation links (for modals/sections)
        navLinks.forEach(link => {
            link.addEventListener('click', (event) => {
                event.preventDefault();
                const sectionId = event.target.dataset.section;
                const modalId = event.target.dataset.modal;
                const action = event.target.dataset.action;
                const scrollToTarget = event.target.dataset.scrollTo; // New attribute

                if (sectionId) {
                    showSection(sectionId);
                } else if (modalId === 'settings-modal') {
                    settingsModal.classList.add('open');
                } else if (modalId === 'upgrades-sidebar-modal') {
                    upgradesSidebarModal.classList.add('open');
                    // Ensure upgrades are rendered before attempting to scroll
                    renderUpgrades();
                    if (scrollToTarget) {
                        // Allow modal to open before scrolling
                        setTimeout(() => {
                            const targetElement = document.getElementById(scrollToTarget);
                            if (targetElement) {
                                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        }, 300); // Match modal transition time
                    }
                } else if (action === 'rebig-bang') { // Changed from 'new-game-strong-start'
                    confirmRebigBang(); // Changed function call
                }
                sidebar.classList.remove('open'); // Close sidebar after selection
            });
        });

        // Close Upgrades Sidebar
        closeUpgradesSidebarButton.addEventListener('click', () => {
            hideModal(upgradesSidebarModal);
        });

        // Settings Modal Interactions
        releaseNotesButton.addEventListener('click', () => {
            hideModal(settingsModal); // Hide settings modal when opening release notes
            releaseNotesModal.classList.add('open');
            renderReleaseNotes(); // Populate and display release notes
        });

        closeReleaseNotesModalButton.addEventListener('click', () => {
            hideModal(releaseNotesModal);
        });

        deleteDataButton.addEventListener('click', () => {
            confirmationStep = 0; // Reset confirmation step for deletion
            confirmDeleteData();
        });

        closeSettingsModalButton.addEventListener('click', () => {
            hideModal(settingsModal);
        });

        // Generic modal close buttons (on confirmation and settings modals, and new upgrades sidebar, and release notes modal)
        modalCloseButtons.forEach(button => {
            button.addEventListener('click', () => {
                hideModal(button.closest('.modal') || button.closest('.upgrades-sidebar'));
            });
        });

        // Generic Confirmation Modal button listeners
        modalConfirmButton.addEventListener('click', () => {
            if (currentConfirmCallback) {
                currentConfirmCallback();
            }
            // Reset modal specific state if needed is handled in hideModal now
        });

        modalCancelButton.addEventListener('click', () => {
            if (currentCancelCallback) {
                currentCancelCallback();
            }
            // Reset modal specific state if needed is handled in hideModal now
        });

        // Volume control listeners
        volumeSlider.addEventListener('input', () => {
            const volume = parseFloat(volumeSlider.value) / 100;
            audioElement.volume = volume;
            if (volume > 0) {
                audioElement.muted = false;
                lastVolumeBeforeMute = volume; // Update last volume if not muted
            }
            updateSpeakerIcon(audioElement.volume, audioElement.muted);
        });

        speakerIcon.addEventListener('click', () => {
            if (audioElement.muted) {
                audioElement.muted = false;
                // Restore previous volume or default if no previous volume
                audioElement.volume = lastVolumeBeforeMute > 0 ? lastVolumeBeforeMute : 0.5;
                volumeSlider.value = audioElement.volume * 100;
            } else {
                lastVolumeBeforeMute = audioElement.volume; // Save current volume before muting
                audioElement.muted = true;
                volumeSlider.value = 0; // Move slider to 0 when muted
            }
            updateSpeakerIcon(audioElement.volume, audioElement.muted);
            // Attempt to play if it was paused and just unmuted
            if (!audioElement.paused && !audioElement.muted) {
                audioElement.play().catch(e => console.error("Autoplay on unmute failed:", e));
            }
        });

        // Initialize game on window load
        window.onload = async () => {
            await initDb();
            await loadGame();
            renderUpgrades(); // Initial render of upgrades list

            // Initialize audio settings from loaded game state
            audioElement.volume = gameState.volume;
            volumeSlider.value = gameState.volume * 100;
            updateSpeakerIcon(audioElement.volume, audioElement.muted);
            // Attempt to play music. It might be blocked until user interaction.
            audioElement.play().catch(e => {
                console.warn("Autoplay blocked. Music will start on first user interaction (e.g., clicking the star).", e);
                // If autoplay is blocked, ensure the initial state reflects this
                audioElement.muted = true; // Mark as muted if it couldn't play
                volumeSlider.value = 0;
                updateSpeakerIcon(0, true);
            });

            setInterval(autoClickLoop, 100); // Auto-click every 100ms
            setInterval(checkHeatClickerReset, 500); // Check heat clicker reset every 500ms
            // Set initial active section
            showSection('game'); // Ensure the game section is active on load
        };
    </script>
</body>
</html>
