const {
  Client,
  Intents,
  Collection,
  MessageEmbed,
  MessageAttachment,
  MessageActionRow,
  MessageButton,
  GatewayIntentBits,
  AttachmentBuilder,
  Events,
  Guilds,
  Discord,
} = require("discord.js");
const client = new Client({
  intents: [
    Intents.FLAGS.GUILDS,
    Intents.FLAGS.GUILD_MESSAGES,
    Intents.FLAGS.GUILD_MEMBERS,
    Intents.FLAGS.GUILD_MESSAGE_REACTIONS,
    "GUILD_MEMBERS",
    "GUILD_MESSAGES",
  ],
});

const Canvas = require("canvas");
const extras = require("canvas-extras");
const cirno = require('./chara.json');
const datas = require("./mongoget.js");

const ignoredChannelIds = ['1137055566754217996', //えーりん
                           '1134131532181815316', //発狂
                          ];

const ranking = {}
exports.level = function () {
  client.on("messageCreate", async (message) => {
    if (!message.guild || message.author.bot) return;
    if (ignoredChannelIds.includes(message.channel.id)) {
        return console.log("XP対象外")
    }
    const Cirno = await datas.get("user", message.author.id)
    if (!Cirno) {
      Cirno.data = cirno
      Cirno.data.chara.NAME = message.member.displayName
      await datas.save(Cirno, message.author.id)
    }
    if (!Cirno.data.chara.User) {
      Cirno.data.chara.User = {
        "TotalAction":{
          "numPing": 0,
          "numShst": 0,
          "numTask": 0,
          "numSell": 0,
          "numBuy": 0,
          "numLogin":0
        }
      }
      await datas.save(Cirno, message.author.id)
      console.log(Cirno.data.chara.NAME+"更新")
    }
    
    const rank = Cirno.data.chara.lv
    Cirno.data.chara.NAME = message.member.displayName
    
    if (rank.giveXp.min > rank.giveXp.max) {
      [rank.giveXp.min, rank.giveXp.max] = [rank.giveXp.max, rank.giveXp.min]; // もしminがmax以上だったら入れ替える
    }
    const xpToAdd = Math.floor(Math.random() * (rank.giveXp.max - rank.giveXp.min + 1)) + rank.giveXp.min;
    rank.text.xp += xpToAdd;
    rank.text.Totalxp += xpToAdd;
    rank.text.seasonTotalxp += xpToAdd;
    while (rank.text.xp >= rank.text.Nextxp) {
      rank.text.lv ++;
      rank.text.xp -= rank.text.Nextxp;
      rank.text.Nextxp = Math.floor(rank.text.Nextxp * 1.1);
      if (Cirno.data.setting.Lvnotice === "true") {
        client.channels.cache
          .get("1201370550220632095").send({ content: `${message.author}のレベルが${rank.text.lv}になったよ！`});
      } else {
        var a = message.member.displayName ?? message.member.nickname
        client.channels.cache.get("1201370550220632095").send({ content: `${message.member.displayName}のレベルが${rank.text.lv}になったよ！`});
      }
    }
    Cirno.data.chara.lv = rank
    await datas.save(Cirno, message.author.id)
    
    if (message.content.startsWith("ci!ranking")) {
      const args = message.content.split(" ");

      let requestedPage;

      if (!isNaN(args[1])) {
        requestedPage = parseInt(args[1]);
      } else if (args.length >= 3 && !isNaN(args[2])) {
        requestedPage = parseInt(args[2]);
      } else {
        requestedPage = 1;
      }
      
      let category = "T";

      if (args.length >= 2 && /^[a-zA-Z]+$/.test(args[1])) {
        category = args[1].toUpperCase();
      }
      
      let nam = category
      switch (nam) {
        case 'T':
          nam = "Lv"
          break;
        case 'P':
          nam = "探索Lv"
          break;
        case 'C':
          nam = "通話Lv"
          break;
        default:
          nam = "Lv"
          break;
      }
      const emb = new MessageEmbed()
        .setAuthor({ name: `${nam} Ranking` })
        .setColor("#66fffc")
        .setTitle("ランキング取得中...(時間がかかる場合があります。)");

      const msg = await message.channel.send({ embeds: [emb] });

      const guild = message.guild;
      const members = await guild.members.fetch();
      const users = members.filter((member) => !member.user.bot);
      const userStats = [];

      for (const [memberId, member] of users) {
        const user = member.user;
        const userId = user.id;
        const nickname = member.nickname ?? user.username;

        const Cirno = await datas.get("user", userId)
        let rank;

        if (category === "T") {
          rank = Cirno.data.chara.lv.text;
        } else if (category === "P") {
          rank = Cirno.data.chara.lv.probe;
        } else if (category === "V") {
          rank = Cirno.data.chara.lv.voice;
        } else {
          rank = Cirno.data.chara.lv.text;
        }

        userStats.push({ na: nickname, lv: rank.lv, to: rank.Totalxp });
      }

      const result = sortBy(userStats, "DESC", "to", "lv", "na");
      const pageSize = 10; // ページごとのランキング表示数
      
      const paginatedItems = paginateItems(result, pageSize);

      const page = requestedPage > 0 ? requestedPage : 1;
      const startIndex = (page - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      const paginatedResult = result.slice(startIndex, endIndex);
      
      emb.setAuthor({ name: `${nam} Ranking` })
        .setColor("#66fffc")
        .setTitle(`Page ${page}`);

      for (let i = 0; i < paginatedResult.length; ++i) {
        emb.addFields({
          name: `${startIndex + i + 1}位：${paginatedResult[i].na}`,
          value: `Lv:${paginatedResult[i].lv}, XP:${paginatedResult[i].to}`,
        });
      }

      ranking[msg.id] = {
        page: requestedPage,
        type: category
      }
      console.log(ranking[msg.id])
      console.log(msg.id)
      console.log(ranking)

            // 最初のページかを検知
      const isFirstPage = requestedPage === 1;

      // 最後のページかを検知
      const isLastPage = requestedPage === paginatedItems.length;
      
      const buttons = [
       new MessageButton() .setCustomId("r_back") .setStyle("SECONDARY") .setEmoji('1202156579378712577') .setDisabled(isFirstPage),
       new MessageButton() .setCustomId("r_next") .setStyle("SECONDARY") .setEmoji('1202156533949923328') .setDisabled(isLastPage),
     ]

      msg.edit({ embeds: [emb], components: [new MessageActionRow().addComponents(buttons)] });
      tasksetting(7, message.author.id, message)
    }
    
    if (message.content === "ci!level") {
      if ( message.channel.type === "GUILD_TEXT" || message.channel.type === "GUILD_PUBLIC_THREAD" || message.channel.type === "GUILD_PRIVATE_THREAD" ) {
        await ifmap(message.author.id)
        const guild = message.guild;
        const members = await guild.members.fetch();
        const users = members.filter((member) => !member.user.bot); // Botを除外する
        async function map(type) {
          const userStats = [];
          for (const [memberId, member] of users) {
            const user = member.user;
            const userId = user.id;
            const nickname = member.nickname ?? user.username; // ニックネームがある場合は、それを使用し、それ以外の場合はユーザー名を使用する
            let rank
            const Cirno = await datas.get("user", userId)
            switch(type){
              case "text":
                rank = Cirno.data.chara.lv.text
              break;
              case "voice":
                rank = Cirno.data.chara.lv.voice
              break;
            }

            userStats.push({ na: nickname, xp: rank.xp, lv: rank.lv });
          } 
          return userStats
        }
        const name = `${message.member.displayName ?? message.author.username}`;
        const resultIndex = searchObjectByPropertyValue(sortBy(await map("text"), "DESC", "lv", "xp", "na"), "na", name);
        const resultIndex2 = searchObjectByPropertyValue(sortBy(await map("voice"), "DESC", "lv", "xp", "na"), "na", name);
        const rank = Cirno.data.chara.lv.text
        const probe = Cirno.data.chara.lv.probe
        const voice = Cirno.data.chara.lv.voice

        var kmtb = formatNumber(rank.Nextxp);
        var skmtb = formatNumber(probe.Nextxp);
        const canvas = Canvas.createCanvas(700, 350);
        const ctx = canvas.getContext("2d");
        const background = await Canvas.loadImage("https://minntogames.github.io/atai-bot.github.io/new/card.png");
        const avatar = await Canvas.loadImage(message.member.avatarURL({ dynamic: true, format: "png" }) || message.author.displayAvatarURL({ dynamic: true, format: "png" }));

        ctx.drawImage(background, 0, 0, canvas.width, canvas.height); //後ろの背景
        ctx.strokeStyle = "#71c3ff";

        ctx.font = applyText(canvas, `${message.member.displayName}`); //ユーザー名
        ctx.fillStyle = "#ffffff";
        ctx.fillText(`${message.member.displayName}`, canvas.width / 16.5, canvas.height / 4);
        ctx.font = "30px sans-serif";
        ctx.fillStyle = "#66fffc";
        ctx.fillText(`Lv ${rank.lv}  #${resultIndex + 1} To:${rank.Totalxp}XP`, canvas.width / 8, canvas.height / 2.45);
        ctx.fillText(`Lv ${voice.lv} #${resultIndex2 + 1} To:${voice.Totalxp}XP`, canvas.width / 8, canvas.height / 1.62);
        ctx.fillText(`Lv ${probe.lv}  To:${probe.Totalxp}XP`, canvas.width / 8, canvas.height / 1.25);

        ctx.fillStyle = "#ffffff";
        ctx.strokeStyle = "#000000";
        ctx.font = "28px sans-serif";

        ctx.beginPath();
        ctx.progressBar(rank.xp, rank.Nextxp, canvas.width / 8, canvas.height / 2.4, 350, 30, Cirno.data.setting.Usercolor, "dimgray");
        var kmtb = formatNumber(rank.Nextxp);
        ctx.strokeText( `XP${rank.xp}/${kmtb}`, canvas.width / 7.5, canvas.height / 2.05);
        ctx.fillText( `XP${rank.xp}/${kmtb}`, canvas.width / 7.5, canvas.height / 2.05);

        ctx.beginPath();
        ctx.progressBar(voice.xp, voice.Nextxp, canvas.width / 8, canvas.height / 1.6, 350, 30, Cirno.data.setting.Usercolor, "dimgray");
        var kmtb = formatNumber(voice.Nextxp);
        ctx.strokeText( `XP${voice.xp}/${kmtb}`, canvas.width / 7.5, canvas.height / 1.44);
        ctx.fillText( `XP${voice.xp}/${kmtb}`, canvas.width / 7.5, canvas.height / 1.44);

        ctx.beginPath();
        ctx.progressBar(probe.xp, probe.Nextxp, canvas.width / 8, canvas.height / 1.23, 350, 30, Cirno.data.setting.Usercolor, "dimgray");
        var kmtb = formatNumber(probe.Nextxp);
        ctx.strokeText( `XP${probe.xp}/${kmtb}`, canvas.width / 7.5, canvas.height / 1.13);
        ctx.fillText( `XP${probe.xp}/${kmtb}`, canvas.width / 7.5, canvas.height / 1.13);

        ctx.beginPath();
        ctx.arc(580, 125, 105, 0, Math.PI * 2, true);
        ctx.fillStyle = Cirno.data.setting.Usercolor
        ctx.fill("evenodd");

        ctx.beginPath();
        ctx.arc(580, 125, 100, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(avatar, 480, 25, 200, 200);

        const attachment = new MessageAttachment( canvas.toBuffer(), "level.png");
        
        message.channel.send({ content:"\n",files: [attachment] });
        tasksetting(2, message.author.id, message)
      }
    }
    
    if (message.content === "ci!graf") {
      await ifmap(message.author.id)
      
      const canvasWidth = 800;
      const canvasHeight = 600;

      // グラフのマージン
      const margin = {
        top: 50,
        bottom: 50,
        left: 100,
        right: 50,
      };
      const guild = message.guild;
      const members = await guild.members.fetch();
      const users = members.filter((member) => !member.user.bot); // Botを除外する
      const userStats = [];
      for (const [memberId, member] of users) {
        const user = member.user;
        const userId = user.id;
        const nickname = member.nickname ?? user.username; // ニックネームがある場合は、それを使用し、それ以外の場合はユーザー名を使用する

        const Cirno = await datas.get("user", userId);
        const rank = Cirno.data.chara.lv.text
          
        userStats.push({ label: nickname, value1: rank.Totalxp, value2: rank.lv, color: Cirno.data.setting.Usercolor});
      }
      const data = sortBy(userStats, "DESC", "value2", "value1", "label");
      const name = `${message.member.displayName ?? message.author.username}`;
      const resultIndex = searchObjectByPropertyValue(data, "label", name);
      const emb = new MessageEmbed()
      .addFields({name: `ユーザー：${name}の詳細`,value: `順位：**${resultIndex + 1}**\nXP：**${rank.text.Totalxp}**\nLv：**${rank.text.lv}**` })
      .setColor(`${Cirno.data.setting.Usercolor ?? "#000000"}`);

      // グラフの描画
      function drawBarChart() {
        const canvas = Canvas.createCanvas(canvasWidth, canvasHeight);
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        const graphWidth = canvasWidth - margin.left - margin.right;
        const graphHeight = canvasHeight - margin.top - margin.bottom;

        const values1 = data.map(d => d.value1);
        const values2 = data.map(d => d.value2);
        const maxValue = Math.max(...values1, ...values2);

        const stepSize = Math.ceil(maxValue / 5);
        const numGridLines = Math.ceil(maxValue / stepSize);
        const gridLineHeight = graphHeight / numGridLines;

        const originX = margin.left;
        const originY = canvasHeight - margin.bottom;

        const barWidth = 40;
        const barSpacing = 30;

        // データ1の描画
        for (let i = 0; i < data.length; i++) {
          const x = originX + i * (barWidth + barSpacing);
          const y = originY - data[i].value1 * (graphHeight / maxValue);

          // 棒の描画
          ctx.fillStyle = data[i].color == "#66fffc" ? '#0088cc' : data[i].color ;
          ctx.fillRect(x, y, barWidth, data[i].value1 * (graphHeight / maxValue));

          // データの数を描画
          var kmtb = formatNumber(data[i].value1);
          ctx.fillStyle = '#000000';
          ctx.font = '14px Arial';
          ctx.fillText(kmtb, x + 10, y - 5);

          // ラベルを縦書きで描画（90度回転）
          ctx.save();
          ctx.translate(x + barWidth / 2 + 32, originY - 5); // x座標を調整
          ctx.rotate(-Math.PI / 2);
          ctx.fillStyle = '#000000';
          ctx.font = '14px Arial';
          ctx.fillText(data[i].label, 0, 0);
          ctx.restore();
        }

        // データ2（value2）の描画
        for (let i = 0; i < data.length; i++) {
          const x = originX + i * (barWidth + barSpacing) + 10;
          const y = originY; // 棒の下に移動

          // 棒の描画
          ctx.fillStyle = "#00cc00" // Lvの色を緑に'#00cc00'
          ctx.fillRect(x, y, barWidth, data[i].value2 * (graphHeight / maxValue));

          // データの数を描画
          ctx.fillStyle = '#000000';
          ctx.font = '14px Arial';
          ctx.fillText(data[i].value2, x + 12, y + 15);

          // Lvの横にvalue2を描画
          ctx.fillStyle = '#000000';
          ctx.font = '14px Arial';
          ctx.fillText('Lv', x - 10, y + 15);
        }

        // 横軸の描画
        ctx.beginPath();
        ctx.moveTo(originX, originY);
        ctx.lineTo(originX + graphWidth, originY);
        ctx.strokeStyle = '#000000';
        ctx.stroke();

        // 縦軸の描画
        ctx.beginPath();
        ctx.moveTo(originX, originY);
        ctx.lineTo(originX, originY - graphHeight);
        ctx.strokeStyle = '#000000';
        ctx.stroke();

        // 縦軸の目盛りを描画
        for (let i = 0; i <= numGridLines; i++) {
          const y = originY - i * gridLineHeight;
          ctx.beginPath();
          ctx.moveTo(originX - 5, y);
          ctx.lineTo(originX, y);
          ctx.strokeStyle = '#000000';
          ctx.stroke();

          // 目盛りの値を描画
          ctx.fillStyle = '#000000';
          ctx.font = '14px Arial';
          let a = i * stepSize
          var kmtb = formatNumber(a);
          ctx.fillText(kmtb, originX - 40, y + 5);
        }

       const attachment = new MessageAttachment( canvas.toBuffer(), "level.png");

       message.channel.send({ files: [attachment], embeds: [emb] });
       tasksetting(8, message.author.id, message)
      }

      // グラフの描画を実行
      drawBarChart();

          }
    
  });
  
  client.on('interactionCreate', async (interaction) => {
    if (!['r_back', 'r_next'].includes(interaction.customId)) {
      return;
    }
    console.log(ranking[interaction.id])
    const emb = new MessageEmbed()

    const Cirno = await datas.get("user", interaction.user.id);

    let i, type
    if (ranking[interaction.id]) {
      i = ranking[interaction.id].page || 1 
      type = ranking[interaction.id].type || "T"

      console.log("通過")
      if (interaction.customId === 'r_back'){
        i--
      } else if (interaction.customId === 'r_next') {
        i++
      }
      ranking[interaction.id] = {
        page: i,
        type
      }
    } else {
      ranking[interaction.id] = {
        page: 1,
        type: "T"
      }
    }
    console.log(ranking[interaction.meesage.id])
    
    console.log(interaction.messageid)
    
    console.log(ranking)
    
    const guild = interaction.guild;
    const members = await guild.members.fetch();
    const users = members.filter((member) => !member.user.bot);
    const userStats = [];

    for (const [memberId, member] of users) {
      const user = member.user;
      const userId = user.id;
      const nickname = member.nickname ?? user.username;

      const Cirno = await datas.get("user", userId)
      let rank;

      if (type === "T") {
        rank = Cirno.data.chara.lv.text;
      } else if (type === "P") {
        rank = Cirno.data.chara.lv.probe;
      } else if (type === "V") {
        rank = Cirno.data.chara.lv.voice;
      } else {
        rank = Cirno.data.chara.lv.text;
      }

      userStats.push({ na: nickname, lv: rank.lv, to: rank.Totalxp });
    }

    const result = sortBy(userStats, "DESC", "to", "lv", "na");

    const pageSize = 10; // ページごとのランキング表示数

    const paginatedItems = paginateItems(result, pageSize);

    const page = i > 0 ? i : 1;
    const startIndex = (page - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    const paginatedResult = result.slice(startIndex, endIndex);


            // 最初のページかを検知
    const isFirstPage = i === 1;

    // 最後のページかを検知
    const isLastPage = i === paginatedItems.length;

    const buttons = [
     new MessageButton() .setCustomId("r_back") .setStyle("SECONDARY") .setEmoji('1202156579378712577') .setDisabled(isFirstPage),
     new MessageButton() .setCustomId("r_next") .setStyle("SECONDARY") .setEmoji('1202156533949923328') .setDisabled(isLastPage),
    ]
    emb.setAuthor({ name: `${type} Ranking` })
      .setColor("#66fffc")
      .setTitle(`Page ${i}`);

    await interaction.update({ embeds: [emb], components: [new MessageActionRow().addComponents(buttons)] });
  });
};

const applyText = (canvas, text) => {
  const context = canvas.getContext("2d");
  let fontSize = 60;
  do {
    context.font = `${(fontSize -= 8)}px sans-serif`;
  } while (context.measureText(text).width > canvas.width - 300);

  return context.font;
};

function formatNumber(number) {
    if (number < 1000) {
        return number.toString();
    }

    const units = ["k", "m", "b", "t", "p", "e", "z"];
    const decimals = [2, 1, 0];

    let unitIndex = 0;
    while (number >= 1e3 && unitIndex < units.length) {
        number /= 1e3;
        unitIndex++;
    }

    const decimalIndex = Math.floor(Math.log10(number));
    const fixedDecimals = decimals[Math.max(decimalIndex, 0)];

    return number.toFixed(fixedDecimals) + (unitIndex > 0 ? units[unitIndex - 1] : "");
}

var sortBy = function (array, order) {
  /**
 * 二次元配列または連想配列の並び替え
 * @param {*[]} array 並び替える配列
 * @param {'ASC'|'DESC'} [order] 並び替える方法
 * @param {...*} args 並び替えの基準となるキー
 * @return {*[]} 並び替えられた配列
 */
  if (!order || !order.match(/^(ASC|DESC)$/i)) order = "ASC";
  order = order.toUpperCase();

  var keys = [];
  for (var i = 2, len = arguments.length; i < len; i++) keys.push(arguments[i]);

  var targets = [].concat(array);

  targets.sort(function (a, b) {
    for (var i = 0, len = keys.length; i < len; i++) {
      if (typeof keys[i] === "string") {
        if (order === "ASC") {
          if (a[keys[i]] < b[keys[i]]) return -1;
          if (a[keys[i]] > b[keys[i]]) return 1;
        } else {
          if (a[keys[i]] > b[keys[i]]) return -1;
          if (a[keys[i]] < b[keys[i]]) return 1;
        }
      } else {
        var localOrder = keys[i].order || "ASC";
        if (!localOrder.match(/^(ASC|DESC)$/i)) order = "ASC";
        order = order.toUpperCase();

        if (localOrder === "ASC") {
          if (a[keys[i].key] < b[keys[i].key]) return -1;
          if (a[keys[i].key] > b[keys[i].key]) return 1;
        } else {
          if (a[keys[i].key] > b[keys[i].key]) return -1;
          if (a[keys[i].key] < b[keys[i].key]) return 1;
        }
      }
    }

    return 0;
  });

  return targets;
};

function searchObjectByPropertyValue(array, property, searchStr) {
  for (let i = 0; i < array.length; i++) {
    const value = array[i][property];
    if (value && value.includes(searchStr)) {
      return i;
    }
  }
  return -1;
}

async function tasksetting(tasknumber, userid, msg) {
  const Cirno = await datas.get("user", userid)
  const user = await datas.get("day", userid)
  const s = await datas.get("day", 'task')
  if (!user.data.task){ user.data.task = [] }
  if (findMatchingObject2(tasknumber, user.data.task) == true) {
    return; 
  } else {
    if (findMatchingObject(tasknumber, s.data.task) == true) {
      msg.reply('課題達成！200XPゲット！');
      Cirno.data.chara.lv.text.xp += 200
      Cirno.data.chara.lv.text.Totalxp += 200
      Cirno.data.chara.lv.text.seasonTotalxp += 200;
      Cirno.data.chara.User.TotalAction.numTask++
      user.data.task.push(tasknumber)
      await datas.save(Cirno, userid)
      await datas.save(user, userid)
    } else {
      return;
    }
  }
}
function findMatchingObject(tasknumber, b) {
  return b.some(item => item.id == tasknumber);
}
function findMatchingObject2(tasknumber, b) {
  return b.some(item => item == tasknumber);
}
async function ifmap(id, a) {
  const user = await datas.get("day", id)
  user.data.ifping = true
  await datas.save(user, id)
}

function paginateItems(items, itemsPerPage) {
  const totalPages = Math.ceil(items.length / itemsPerPage);

  const paginatedItems = [];
  for (let page = 1; page <= totalPages; page++) {
    const startIndex = (page - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    paginatedItems.push(items.slice(startIndex, endIndex));
  }

  return paginatedItems;
}

client.login(process.env.TOKEN);
