<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://youtube.minntelia.com/image/icon.ico">
    <title>おもちゃ箱</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            /* タッチデバイスでのハイライト無効化 */
            -webkit-tap-highlight-color: transparent;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* UIがクリックを阻害しないようにする */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        #title-display {
            text-align: center;
            color: #fff;
            text-shadow: 4px 4px 0 #000;
            margin-top: 10vh;
        }
        h1 {
            font-size: 3rem;
            margin: 0;
            letter-spacing: 0.1em;
            background: linear-gradient(to bottom, #ffcc00, #ff6600);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        h2 {
            font-size: 1.5rem;
            color: #ccc;
            margin-top: 10px;
        }
        #page-indicator {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 20px;
        }
        .indicator-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .indicator-dot.active {
            background: #fff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            transform: scale(1.3);
        }
        .indicator-dot:hover {
            background: rgba(255, 255, 255, 0.6);
        }
        #controls-hint {
            text-align: center;
            color: #fff;
            font-size: 1.2rem;
            margin-bottom: 20px;
            opacity: 0.8;
            text-shadow: 2px 2px 0 #000;
        }
        .key {
            display: inline-block;
            background: #444;
            border: 2px solid #888;
            border-radius: 4px;
            padding: 2px 8px;
            margin: 0 4px;
            font-weight: bold;
            color: #fff;
            box-shadow: 0 4px 0 #222;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
        }
        #game-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 9999;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #game-loading.active {
            display: flex;
        }
        .loading-text {
            color: #fff;
            font-size: 2rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff6600;
            animation: pulse 1s infinite;
        }
        .loading-bar {
            width: 300px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            background: #333;
        }
        .loading-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ffcc00);
            animation: loading-progress 1.1s linear;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        @keyframes loading-progress {
            0% { width: 0%; }
            100% { width: 100%; }
        }
    </style>
</head>
<body>

    <div id="loading">LOADING 3D ASSETS...</div>

    <div id="game-loading">
        <div class="loading-text">NOW LOADING...</div>
        <div class="loading-bar">
            <div class="loading-bar-fill"></div>
        </div>
    </div>

    <div id="ui-layer">
        <div id="title-display">
            <h1 id="game-title">GAME TITLE</h1>
            <h2 id="game-genre">Genre / 198X</h2>
            <!-- ページインジケーター -->
            <div id="page-indicator"></div>
        </div>
        <!-- マウス操作の説明 -->
        <div id="controls-hint">
            <span class="key">SCROLL</span> / <span class="key">←</span><span class="key">→</span> SELECT &nbsp;&nbsp; 
            <span class="key">CLICK</span> INSERT
        </div>
    </div>

    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // --- 設定定数 ---
        const CONFIG = {
            cartSpacing: 3.5,     // カセット間の距離
            scrollSpeed: 0.15,    // スクロールの滑らかさ (0-1)
            insertSpeed: 0.15,    // 挿入アニメーションの速さ
            cartColors: [
                0x3366cc, // 青
                0xcc3333, // 赤
                0x33cc66, // 緑
                0xcccc33, // 黄
                0xcc33cc, // 紫
                0x33cccc, // 水色
                0x333333, // 黒
                0xeeeeee  // 白
            ]
        };

        // --- ゲームデータ (画像URLとリンク先を追加) ---
        // Picsum Photosを使用してランダムな画像を表示します
        const GAMES = [
            { title: "ばうんすばうんす", genre: "Minntogames / 2025", color: 0x00F6FF, imageUrl: "../image/label/bounce.png", url: "../games/bouncebounce" }, 
            { title: "Neon Defense", genre: "Minntogames / 2025", color: 0xaa00ff, imageUrl: "../image/label/neon.png", url: "../games/tower" }, 
            { title: "Star Clicker", genre: "Minntogames / 2025", color: 0x0055AA, imageUrl: "../image/label/space.png", url: "../games/starclicker" }, 
            { title: "Dungeon RPG", genre: "Minntogames / 2022", color: 0x222222, imageUrl: "../image/label/dungeon.png", url: "../games/dungeons" }, 
            { title: "Card Crash Duel", genre: "Minntogames / 2025", color: 0x888888, imageUrl: "../image/label/card.png", url: "../games/turnbattle" }, 
            { title: "Labyrinth", genre: "Minntogames / 2022", color: 0xFF6600, imageUrl: "../image/label/labyrinth.png", url: "../games/Maze2" }, 
            { title: "Tetris(もどき)",genre: "Minntogames / 2022", color: 0xAA00AA, imageUrl: "../image/label/tetris.png", url: "../games/tetris" },
            { title: "Dynamic Rhythm", genre: "Piyo / 2025", color: 0x8800ff, imageUrl: "../image/label/rhythm.png", url: "https://piyoutube.github.io/TJA3D" }  
        ];

        // --- ステート管理 ---
        const state = {
            selectedIndex: 0,       // 現在選択中のインデックス（整数）
            visualIndex: 0,         // アニメーション用の現在位置（浮動小数点）
            targetIndex: 0,         // 目標インデックス
            isInserted: false,      // カセットが刺さっているか
            insertProgress: 0,      // 挿入アニメーションの進行度 (0:手元, 1:刺さってる)
            cameraShake: 0,         // 挿入時の衝撃用
            scrollCooldown: false,
            isLoading: false,       // ローディング中かどうか
            touchStartX: 0,         // タッチ開始位置X
            touchStartY: 0          // タッチ開始位置Y
        };

        // --- Three.js 初期化 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x201818);
        scene.fog = new THREE.Fog(0x201818, 10, 30);

        // スマホ判定
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        // スマホの場合はカメラを遠めに配置
        const cameraZ = isMobile ? 15 : 11;
        camera.position.set(0, 6, cameraZ);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        document.getElementById('loading').style.display = 'none';

        // --- ライト ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const spotLight = new THREE.SpotLight(0xffaa00, 20);
        spotLight.position.set(0, 10, 0);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 0.5;
        scene.add(spotLight);

        // --- マテリアル ---
        const materials = {
            consoleBody: new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.3 }),
            consoleWhite: new THREE.MeshStandardMaterial({ color: 0xEEE8D5, roughness: 0.4 }),
            consoleBlack: new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 }),
            plastic: new THREE.MeshStandardMaterial({ roughness: 0.2, metalness: 0.1 }),
            // ラベル用マテリアルはカセットごとに生成するのでここでは定義しない
        };

        // --- オブジェクト生成: コンソール (ファミコン風) ---
        const consoleGroup = new THREE.Group();
        scene.add(consoleGroup);

        function createConsole() {
            // ベースボディ
            const bodyGeo = new RoundedBoxGeometry(7, 2, 5.5, 4, 0.2);
            const body = new THREE.Mesh(bodyGeo, materials.consoleBody);
            body.position.y = -1;
            body.receiveShadow = true;
            body.castShadow = true;
            consoleGroup.add(body);

            // 前面の白いパネル
            const frontPanelGeo = new THREE.BoxGeometry(7.1, 0.8, 2);
            const frontPanel = new THREE.Mesh(frontPanelGeo, materials.consoleWhite);
            frontPanel.position.set(0, -0.6, 1.8);
            frontPanel.receiveShadow = true;
            frontPanel.castShadow = true;
            consoleGroup.add(frontPanel);

            // 中央のスロット部分
            const leftWallGeo = new THREE.BoxGeometry(2.3, 0.5, 2.5);
            const leftWall = new THREE.Mesh(leftWallGeo, materials.consoleWhite);
            leftWall.position.set(-2.4, 0.25, -0.5);
            leftWall.receiveShadow = true;
            leftWall.castShadow = true;
            consoleGroup.add(leftWall);

            const rightWallGeo = new THREE.BoxGeometry(2.3, 0.5, 2.5);
            const rightWall = new THREE.Mesh(rightWallGeo, materials.consoleWhite);
            rightWall.position.set(2.4, 0.25, -0.5);
            rightWall.receiveShadow = true;
            rightWall.castShadow = true;
            consoleGroup.add(rightWall);

            const backWallGeo = new THREE.BoxGeometry(7, 0.5, 1.5);
            const backWall = new THREE.Mesh(backWallGeo, materials.consoleWhite);
            backWall.position.set(0, 0.25, -2.5);
            backWall.receiveShadow = true;
            backWall.castShadow = true;
            consoleGroup.add(backWall);

            // スロットの蓋
            const slotCoverGeo = new THREE.BoxGeometry(2.6, 0.1, 1.5);
            const slotCover = new THREE.Mesh(slotCoverGeo, materials.consoleBlack);
            slotCover.position.set(0, 0.05, -0.5);
            
            const flapGroup = new THREE.Group();
            flapGroup.position.set(0, 0, -1.25);
            flapGroup.add(slotCover);
            slotCover.position.z = 0.75;
            consoleGroup.add(flapGroup);
            state.flap = flapGroup;

            // スロット穴
            const holeGeo = new THREE.PlaneGeometry(2.4, 1.4);
            const holeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const hole = new THREE.Mesh(holeGeo, holeMat);
            hole.rotation.x = -Math.PI / 2;
            hole.position.set(0, 0.01, -0.5);
            consoleGroup.add(hole);
            
            // パワーランプ
            const ledGeo = new THREE.BoxGeometry(0.6, 0.1, 0.3);
            const ledMat = new THREE.MeshStandardMaterial({ color: 0x330000, emissive: 0x000000 });
            const led = new THREE.Mesh(ledGeo, ledMat);
            led.position.set(-2.5, 0.5, 2.2);
            consoleGroup.add(led);
            state.led = led;
        }

        createConsole();

        // --- オブジェクト生成: カセット ---
        const cartridges = [];
        const cartsGroup = new THREE.Group();
        scene.add(cartsGroup);

        function createCartridges() {
            const cartGeo = new RoundedBoxGeometry(2.2, 0.3, 3.2, 2, 0.1);
            
            GAMES.forEach((game, i) => {
                const group = new THREE.Group();
                
                // カセット本体
                const mat = materials.plastic.clone();
                mat.color.setHex(game.color);
                const mesh = new THREE.Mesh(cartGeo, mat);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);

                // --- ラベル生成ロジック (画像対応) ---
                const labelGeo = new THREE.PlaneGeometry(1.8, 2.4);
                
                // Canvasの設定
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 160;
                const ctx = canvas.getContext('2d');

                // 初期描画関数 (画像ロード前または画像なしの場合)
                function drawLabel(img = null) {
                    // 背景
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, 128, 160);

                    // ヘッダーバー (色付き)
                    ctx.fillStyle = '#' + game.color.toString(16).padStart(6, '0');
                    ctx.fillRect(10, 10, 108, 20);

                    if (img) {
                        // 画像がある場合: 描画
                        try {
                            // 画像アスペクト比を維持しつつ枠に収める簡易ロジック
                            ctx.drawImage(img, 10, 35, 108, 80);
                        } catch (e) {
                            console.warn("Image draw failed", e);
                        }
                    } else {
                        // 画像がない場合: プレースホルダーの四角
                        ctx.fillStyle = '#ddd';
                        ctx.fillRect(10, 35, 108, 80);
                        ctx.fillStyle = '#999';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('NO IMAGE', 64, 80);
                    }

                    // タイトルテキスト (下部に配置)
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    
                    const words = game.title.split(' ');
                    if (words.length > 1 && ctx.measureText(game.title).width > 100) {
                        ctx.fillText(words[0], 64, 135);
                        ctx.fillText(words.slice(1).join(' '), 64, 152);
                    } else {
                        ctx.fillText(game.title, 64, 145);
                    }
                }

                drawLabel(null);

                const tex = new THREE.CanvasTexture(canvas);
                tex.minFilter = THREE.LinearFilter; 
                
                if (game.imageUrl) {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        drawLabel(img);
                        tex.needsUpdate = true;
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image for ${game.title}`);
                    };
                    img.src = game.imageUrl;
                }

                const labelMat = new THREE.MeshBasicMaterial({ map: tex });
                const label = new THREE.Mesh(labelGeo, labelMat);
                label.rotation.x = -Math.PI / 2;
                label.position.y = 0.16;
                label.position.z = -0.2;
                group.add(label);

                // グリップ
                const gripGeo = new THREE.BoxGeometry(2.2, 0.05, 0.1);
                const gripMat = new THREE.MeshStandardMaterial({color:0x000000, opacity:0.3, transparent:true});
                const grip = new THREE.Mesh(gripGeo, gripMat);
                grip.position.y = 0.15;
                grip.position.z = 1.2;
                group.add(grip);

                cartsGroup.add(group);
                cartridges.push({
                    mesh: group,
                    baseX: i * CONFIG.cartSpacing,
                    index: i
                });
            });
        }

        createCartridges();

        // --- UI更新関数 ---
        function updateUI(index) {
            document.getElementById('game-title').innerText = GAMES[index].title;
            document.getElementById('game-title').style.color = '#' + GAMES[index].color.toString(16).padStart(6, '0');
            document.getElementById('game-genre').innerText = GAMES[index].genre;
            
            // ページインジケーターの更新
            const dots = document.querySelectorAll('.indicator-dot');
            dots.forEach((dot, i) => {
                if (i === index) {
                    dot.classList.add('active');
                    dot.style.background = '#' + GAMES[index].color.toString(16).padStart(6, '0');
                } else {
                    dot.classList.remove('active');
                    dot.style.background = '';
                }
            });
        }

        // ページインジケーターの生成
        function createPageIndicator() {
            const indicator = document.getElementById('page-indicator');
            GAMES.forEach((game, i) => {
                const dot = document.createElement('div');
                dot.className = 'indicator-dot';
                dot.addEventListener('click', () => {
                    if (!state.isInserted && !state.isLoading) {
                        state.targetIndex = i;
                        updateUI(i);
                    }
                });
                indicator.appendChild(dot);
            });
        }

        createPageIndicator();
        updateUI(0);

        // スマホ用の操作説明を設定
        if (isMobile) {
            document.getElementById('controls-hint').innerHTML = '<span class="key">SWIPE</span> SELECT &nbsp;&nbsp; <span class="key">TAP</span> INSERT';
        }

        // --- 入力処理 ---
        window.addEventListener('keydown', (e) => {
            if (state.isLoading) return; // ローディング中は操作無効
            
            if (state.isInserted) {
                if (e.key === 'x' || e.key === 'X' || e.key === 'Escape' || e.key === 'Backspace' || e.key === 'ArrowUp') {
                    ejectCartridge();
                }
                return;
            }

            switch(e.key) {
                case 'ArrowLeft':
                    changeSelection(-1);
                    break;
                case 'ArrowRight':
                    changeSelection(1);
                    break;
                case 'Enter':
                case ' ':
                    insertCartridge();
                    break;
            }
        });

        window.addEventListener('wheel', (e) => {
            if (state.isLoading) return; // ローディング中は操作無効
            if (state.isInserted) return;
            if (state.scrollCooldown) return;

            if (Math.abs(e.deltaY) > 10) {
                if (e.deltaY > 0) {
                    changeSelection(1);
                } else {
                    changeSelection(-1);
                }
                state.scrollCooldown = true;
                setTimeout(() => { state.scrollCooldown = false; }, 150);
            }
        });

        window.addEventListener('click', () => {
            if (state.isLoading) return; // ローディング中は操作無効
            
            if (state.isInserted) {
                ejectCartridge();
            } else {
                insertCartridge();
            }
        });

        // --- タッチ操作対応 ---
        let touchStartTime = 0;
        
        window.addEventListener('touchstart', (e) => {
            if (state.isLoading) return;
            
            state.touchStartX = e.touches[0].clientX;
            state.touchStartY = e.touches[0].clientY;
            touchStartTime = Date.now();
        }, { passive: true });

        window.addEventListener('touchend', (e) => {
            if (state.isLoading) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const touchDuration = Date.now() - touchStartTime;
            
            const deltaX = touchEndX - state.touchStartX;
            const deltaY = touchEndY - state.touchStartY;
            
            // スワイプの判定（最小距離50px、最大時間500ms）
            if (Math.abs(deltaX) > 50 && touchDuration < 500) {
                if (!state.isInserted) {
                    if (deltaX > 0) {
                        // 右スワイプ → 左へ移動
                        changeSelection(-1);
                    } else {
                        // 左スワイプ → 右へ移動
                        changeSelection(1);
                    }
                }
                e.preventDefault(); // クリックイベントの発火を防ぐ
            } else if (Math.abs(deltaX) < 30 && Math.abs(deltaY) < 30 && touchDuration < 300) {
                // タップ判定（移動が少なく、時間が短い）
                if (state.isInserted && !state.isLoading) {
                    // 挿入中でローディング終了後のみ抜ける
                    ejectCartridge();
                    e.preventDefault(); // クリックイベントの発火を防ぐ
                } else if (!state.isInserted) {
                    // 未挿入時は挿入
                    insertCartridge();
                    e.preventDefault(); // クリックイベントの発火を防ぐ
                }
            }
        });

        function changeSelection(direction) {
            let nextIndex = state.targetIndex + direction;
            // ループ処理: 最後→最初、最初→最後
            if (nextIndex < 0) {
                nextIndex = GAMES.length - 1;
            } else if (nextIndex >= GAMES.length) {
                nextIndex = 0;
            }
            state.targetIndex = nextIndex;
            updateUI(state.targetIndex);
        }

        function insertCartridge() {
            if (state.isInserted) return;
            state.isInserted = true;
            state.isLoading = true; // ローディング開始
            state.insertProgress = 0;
            
            state.led.material.color.setHex(0xFF0000);
            state.led.material.emissive.setHex(0xFF0000);
            state.led.material.emissiveIntensity = 2;

            if (isMobile) {
                document.getElementById('controls-hint').innerHTML = '<span class="key">TAP</span> EJECT';
            } else {
                document.getElementById('controls-hint').innerHTML = '<span class="key">CLICK</span> / <span class="key">X</span> / <span class="key">↑</span> EJECT';
            }

            const loadingScreen = document.getElementById('game-loading');
            
            // 挿入完了後にページを開く(1.5秒後)
            setTimeout(() => {
                const selectedGame = GAMES[state.targetIndex];
                if (selectedGame && selectedGame.url) {
                    if (isMobile) {
                        // スマホは同一タブで移動
                        window.location.href = selectedGame.url;
                    } else {
                        // PCは新しいタブで開く
                        window.open(selectedGame.url, '_blank');
                    }
                }
                // ローディング画面を非表示
                loadingScreen.classList.remove('active');
                state.isLoading = false; // ローディング終了
            }, 1500);

            // ローディング画面を表示
            setTimeout(() => {
                loadingScreen.classList.add('active');
            }, 300);
        }

        function ejectCartridge() {
            if (!state.isInserted) return;
            state.isInserted = false;
            
            state.led.material.color.setHex(0x330000);
            state.led.material.emissive.setHex(0x000000);
            state.led.material.emissiveIntensity = 0;

            if (isMobile) {
                document.getElementById('controls-hint').innerHTML = '<span class="key">SWIPE</span> SELECT &nbsp;&nbsp; <span class="key">TAP</span> INSERT';
            } else {
                document.getElementById('controls-hint').innerHTML = '<span class="key">SCROLL</span> / <span class="key">←</span><span class="key">→</span> SELECT &nbsp;&nbsp; <span class="key">CLICK</span> INSERT';
            }
        }

        // --- アニメーションループ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // 1. スクロール処理（ループを考慮した最短距離で補間）
            let diff = state.targetIndex - state.visualIndex;
            const totalGames = GAMES.length;
            // 最短ルートを計算
            if (diff > totalGames / 2) {
                diff -= totalGames;
            } else if (diff < -totalGames / 2) {
                diff += totalGames;
            }
            state.visualIndex += diff * (delta * 10);
            
            // visualIndexを0-totalGamesの範囲に正規化
            if (state.visualIndex < 0) {
                state.visualIndex += totalGames;
            } else if (state.visualIndex >= totalGames) {
                state.visualIndex -= totalGames;
            }

            // 2. 挿入アニメーション
            if (state.isInserted) {
                state.insertProgress = Math.min(1, state.insertProgress + delta * 3);
            } else {
                state.insertProgress = Math.max(0, state.insertProgress - delta * 4);
            }

            // フラップ
            const targetFlapAngle = state.insertProgress > 0.1 ? -Math.PI / 2.5 : 0;
            state.flap.rotation.x += (targetFlapAngle - state.flap.rotation.x) * delta * 15;

            // 3. カセット位置更新
            cartridges.forEach((cart, i) => {
                const group = cart.mesh;
                // ループを考慮した最短距離を計算
                let relativePos = i - state.visualIndex;
                const totalGames = GAMES.length;
                // -totalGames/2 から +totalGames/2 の範囲に正規化
                if (relativePos > totalGames / 2) {
                    relativePos -= totalGames;
                } else if (relativePos < -totalGames / 2) {
                    relativePos += totalGames;
                }

                if (i === state.targetIndex && state.insertProgress > 0.01) {
                    group.position.x = 0;

                    const p = state.insertProgress;
                    
                    let y = 0.5;
                    let z = 3; 
                    let rotX = 0;
                    let rotZ = 0; // Y軸回転(rotY)を廃止し、Z軸回転(rotZ)を追加

                    if (p < 0.4) {
                        // フェーズ1: 持ち上げ + 予備動作
                        const t = p / 0.4;
                        y = THREE.MathUtils.lerp(0.5, 4.0, t); // 高く上げる
                        z = THREE.MathUtils.lerp(3, 1.5, t);   // 奥へ移動
                        // X軸: 手前側に起き上がり始める (0 -> 60度)
                        rotX = THREE.MathUtils.lerp(0, Math.PI / 3, t); 
                        // Z軸: ひねりを加える (0 -> -30度)
                        rotZ = THREE.MathUtils.lerp(0, -Math.PI / 6, t); 

                    } else if (p < 0.7) {
                        // フェーズ2: 位置合わせ + ひねり解消
                        const t = (p - 0.4) / 0.3;
                        y = THREE.MathUtils.lerp(4.0, 3.5, t); 
                        z = THREE.MathUtils.lerp(1.5, -0.5, t);
                        // X軸: 垂直まで完全に起こす (60度 -> 90度)
                        rotX = THREE.MathUtils.lerp(Math.PI / 3, Math.PI / 2, t);
                        // Z軸: ひねりを戻して真っ直ぐにする (-30度 -> 0度)
                        rotZ = THREE.MathUtils.lerp(-Math.PI / 6, 0, t);

                    } else {
                        // フェーズ3: 挿入
                        const t = (p - 0.7) / 0.3;
                        y = THREE.MathUtils.lerp(3.5, 0.8, t);
                        z = -0.5;
                        rotX = Math.PI / 2; // 垂直(90度)
                        rotZ = 0;           // 水平(0度)

                        if (t > 0.8 && state.cameraShake === 0) {
                            state.cameraShake = 0.5; 
                        }
                    }

                    group.position.y = y;
                    group.position.z = z;
                    group.rotation.x = rotX;
                    group.rotation.y = 0;    // Y軸回転はしない
                    group.rotation.z = rotZ; // Z軸回転を適用

                } else {
                    group.position.x = relativePos * CONFIG.cartSpacing;
                    
                    const dist = Math.abs(relativePos);
                    group.position.z = 3 + (dist * 0.5); 
                    group.position.y = 0.5;

                    group.rotation.y = -relativePos * 0.1;
                    
                    // 選択中のカセットに近いほど前傾させる（なめらかに補間）
                    const tiltAmount = Math.max(0, 1 - Math.abs(relativePos));
                    group.rotation.x = (Math.PI / 12) * tiltAmount; // 15度まで前傾
                    
                    group.rotation.z = 0;

                    if (dist > 3) {
                        const s = Math.max(0, 1 - (dist - 3) * 0.5);
                        group.scale.setScalar(s);
                    } else {
                        group.scale.setScalar(1);
                    }
                }
            });

            // 4. カメラ演出
            if (state.cameraShake > 0) {
                state.cameraShake *= 0.8;
                // camera.position.x = (Math.random() - 0.5) * state.cameraShake;
                // camera.position.y = 6 + (Math.random() - 0.5) * state.cameraShake;
                if (state.cameraShake < 0.01) state.cameraShake = 0;
            } else if (state.insertProgress > 0.01) {
                // 挿入中はカメラを固定
                camera.position.x = 0;
                camera.position.y = 6;
            } else {
                // ループを考慮したカメラの最短距離移動
                let cameraDiff = state.visualIndex - state.targetIndex;
                if (cameraDiff > totalGames / 2) {
                    cameraDiff -= totalGames;
                } else if (cameraDiff < -totalGames / 2) {
                    cameraDiff += totalGames;
                }
                camera.position.x += (cameraDiff * 0.5 - camera.position.x) * 0.05;
                camera.position.y = 6;
            }
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>